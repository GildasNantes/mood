<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Mood Map</title>

<link rel="stylesheet" href="./maplibre-gl.css">

<style>
  html, body { margin:0; height:100%; font:16px system-ui; }
  #map { position:fixed; inset:0; }

  #panel{
    position: fixed;
    z-index: 10;
    left:12px; top:12px;
    width: 320px;
    background: rgba(255,255,255,0.96);
    border-radius: 16px;
    box-shadow: 0 14px 36px rgba(0,0,0,.25);
    padding: 16px;
    padding-bottom: calc(16px + env(safe-area-inset-bottom));
    padding-top: calc(16px + env(safe-area-inset-top));
  }

  h3 { margin:0 0 10px; font-size:18px; }
  .row { display:grid; gap:10px; margin:10px 0; }

  input, button{
    font:inherit;
    padding:12px;
    border-radius:12px;
    border:1px solid rgba(0,0,0,.15);
  }
  button{ background:#111; color:#fff; border:0; cursor:pointer; }
  button.secondary{ background:#eee; color:#111; }
  button:disabled { opacity:.55; cursor:not-allowed; }

  .small{ font-size:13px; opacity:.75; }
  .msg{ white-space:pre-wrap; font-size:13px; margin-top:8px; }

  :root { --vh: 1vh; }
  #map { height: calc(var(--vh) * 100); }

  @media (max-width: 520px) {
    #panel{ width: calc(100vw - 24px); }
    button, input { padding: 14px; font-size: 16px; }
  }
</style>
</head>

<body>
<div id="map"></div>

<div id="panel">
  <h3>Mood Map</h3>

  <div class="row">
    <label>Your mood: <b><span id="moodValue">5</span>/10</b></label>
    <input id="slider" type="range" min="0" max="10" value="5">
  </div>

  <div class="row">
    <button id="btnSave">Locate + Save</button>
  </div>

  <div class="small" id="hint">
    Choose your mood, then tap ‚ÄúLocate + Save‚Äù to reveal the world‚Äôs mood üåç
  </div>

  <div id="msg" class="msg"></div>
</div>

<script src="./maplibre-gl.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

<script>
/* =============================================================================
   0) MOBILE VIEWPORT FIX (iOS)
   ============================================================================= */
function setVh() {
  document.documentElement.style.setProperty('--vh', `${window.innerHeight * 0.01}px`);
}
window.addEventListener('resize', setVh);
setVh();

/* =============================================================================
   1) MAP SETUP
   ============================================================================= */
const map = new maplibregl.Map({
  container: "map",
  style: {
    version: 8,
    sources: {
      osm: {
        type: "raster",
        tiles: [
          "https://a.tile.openstreetmap.org/{z}/{x}/{y}.png",
          "https://b.tile.openstreetmap.org/{z}/{x}/{y}.png",
          "https://c.tile.openstreetmap.org/{z}/{x}/{y}.png"
        ],
        tileSize: 256,
        attribution: "¬© OpenStreetMap contributors"
      }
    },
    layers: [{ id: "osm", type: "raster", source: "osm" }]
  },
  center: [0, 20],
  zoom: 2
});
map.addControl(new maplibregl.NavigationControl(), "top-right");

/* =============================================================================
   2) MOOD ICONS (0..10)
   ============================================================================= */
function lerp(a,b,t){ return a + (b - a) * t; }
function lerpColor(c1,c2,t){
  const r = Math.round(lerp(c1[0], c2[0], t));
  const g = Math.round(lerp(c1[1], c2[1], t));
  const b = Math.round(lerp(c1[2], c2[2], t));
  return `rgb(${r},${g},${b})`;
}
function moodImageData(level, size=96){
  const t = Math.max(0, Math.min(1, level/10));
  const red=[215,25,28], yellow=[255,255,191], green=[26,150,65];
  const fill = (t < 0.5)
    ? lerpColor(red, yellow, t/0.5)
    : lerpColor(yellow, green, (t-0.5)/0.5);

  const canvas = document.createElement("canvas");
  canvas.width = size; canvas.height = size;
  const ctx = canvas.getContext("2d");

  const cx = size/2, cy = size/2, r = size*0.42;

  ctx.beginPath(); ctx.arc(cx, cy+3, r, 0, Math.PI*2);
  ctx.fillStyle="rgba(0,0,0,0.18)"; ctx.fill();

  ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2);
  ctx.fillStyle = fill; ctx.fill();
  ctx.lineWidth = Math.max(3, size*0.04);
  ctx.strokeStyle = "rgba(0,0,0,0.25)";
  ctx.stroke();

  const eyeY = cy - size*0.10, eyeDX=size*0.14, eyeR=size*0.04;
  ctx.beginPath();
  ctx.arc(cx-eyeDX, eyeY, eyeR, 0, Math.PI*2);
  ctx.arc(cx+eyeDX, eyeY, eyeR, 0, Math.PI*2);
  ctx.fillStyle="rgba(0,0,0,0.75)";
  ctx.fill();

  const browY = eyeY - size*0.08;
  const browTilt = lerp(0.20, -0.20, t);
  ctx.lineWidth = Math.max(3, size*0.035);
  ctx.strokeStyle="rgba(0,0,0,0.55)";
  ctx.lineCap="round";

  ctx.beginPath();
  ctx.moveTo(cx-eyeDX-size*0.06, browY + browTilt*size*0.08);
  ctx.lineTo(cx-eyeDX+size*0.06, browY - browTilt*size*0.08);
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(cx+eyeDX-size*0.06, browY - browTilt*size*0.08);
  ctx.lineTo(cx+eyeDX+size*0.06, browY + browTilt*size*0.08);
  ctx.stroke();

  const mouthY = cy + size*0.12, mouthW=size*0.26;
  const curvature = lerp(-1, 1, t);
  ctx.beginPath();
  ctx.moveTo(cx-mouthW, mouthY);
  ctx.quadraticCurveTo(cx, mouthY + curvature*size*0.12, cx+mouthW, mouthY);
  ctx.strokeStyle="rgba(0,0,0,0.70)";
  ctx.lineWidth=Math.max(4, size*0.05);
  ctx.lineCap="round";
  ctx.stroke();

  const img = ctx.getImageData(0,0,size,size);
  return { width: img.width, height: img.height, data: img.data };
}
function ensureMoodImages(){
  for(let lvl=0; lvl<=10; lvl++){
    const name = `mood-${lvl}`;
    if(!map.hasImage(name)) map.addImage(name, moodImageData(lvl,96));
  }
}

/* =============================================================================
   3) POINTS SOURCE + LAYERS
   ============================================================================= */
function initPointsSourceAndLayers(){
  if(map.getSource("points")) return;

  map.addSource("points", {
    type: "geojson",
    data: { type:"FeatureCollection", features: [] },
    cluster: true,
    clusterRadius: 60,
    clusterMaxZoom: 14,
    clusterProperties: { sum: ["+", ["get", "value"]], count: ["+", 1] }
  });

  const avgRoundedClamped = [
    "case",
    ["<", ["round", ["/", ["get","sum"], ["get","count"]]], 0], 0,
    [">", ["round", ["/", ["get","sum"], ["get","count"]]], 10], 10,
    ["round", ["/", ["get","sum"], ["get","count"]]]
  ];

  map.addLayer({
    id: "clusters-mood",
    type: "symbol",
    source: "points",
    filter: ["has", "point_count"],
    layout: {
      "icon-image": ["concat","mood-", ["to-string", avgRoundedClamped]],
      "icon-size": ["step", ["get","point_count"], 0.65, 10, 0.75, 50, 0.9, 200, 1.05, 1000, 1.2],
      "icon-allow-overlap": true,
      "text-field": ["to-string", ["get","point_count"]],
      "text-size": 12,
      "text-offset": [0, 1.55],
      "text-allow-overlap": true,
      "text-anchor": "top"
    },
    paint: {
      "text-color": "rgba(0,0,0,0.75)",
      "text-halo-color": "rgba(255,255,255,0.9)",
      "text-halo-width": 1
    }
  });

  map.addLayer({
    id: "points-mood",
    type: "symbol",
    source: "points",
    filter: ["!", ["has", "point_count"]],
    layout: {
      "icon-image": [
        "concat","mood-",
        ["to-string",
          ["case",
            ["<", ["round", ["get","value"]], 0], 0,
            [">", ["round", ["get","value"]], 10], 10,
            ["round", ["get","value"]]
          ]
        ]
      ],
      "icon-size": 0.55,
      "icon-allow-overlap": true
    }
  });

  map.on("click", "clusters-mood", (e) => {
    const f = e.features[0];
    map.getSource("points").getClusterExpansionZoom(
      f.properties.cluster_id,
      (err, zoom) => {
        if (err) return;
        map.easeTo({ center: f.geometry.coordinates, zoom });
      }
    );
  });

  map.on("mouseenter", "clusters-mood", () => map.getCanvas().style.cursor = "pointer");
  map.on("mouseleave", "clusters-mood", () => map.getCanvas().style.cursor = "");
}

function clearMarkers(){
  const source = map.getSource("points");
  if(!source) return;
  source.setData({ type:"FeatureCollection", features: [] });
}

/* Only reveal after save in THIS session */
let revealedThisSession = false;

async function refreshPoints(sb){
  if (!revealedThisSession) return;

  const source = map.getSource("points");
  if(!source) return;

  const { data, error } = await sb
    .from("mood_entries")
    .select("mood, lon, lat")
    .order("created_at", { ascending:false })
    .limit(20000);

  if(error){
    setMsg("Load failed: " + (error.message || "Unknown error"));
    console.warn("LOAD error:", error);
    return;
  }

  const features = (data || [])
    .filter(r => typeof r.lon==="number" && typeof r.lat==="number")
    .map(r => ({
      type: "Feature",
      properties: { value: r.mood },
      geometry: { type:"Point", coordinates:[r.lon, r.lat] }
    }));

  source.setData({ type:"FeatureCollection", features });
}

/* =============================================================================
   4) UI helpers
   ============================================================================= */
const el = id => document.getElementById(id);
const slider = el("slider");
const moodValue = el("moodValue");
const msg = el("msg");
const btnSave = el("btnSave");

slider.oninput = () => moodValue.textContent = slider.value;

function setMsg(t){ msg.textContent = t || ""; }

/* =============================================================================
   5) Supabase
   ============================================================================= */
const SUPABASE_URL = "https://ugrmxzdhevqrgftlxfnp.supabase.co";
const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVncm14emRoZXZxcmdmdGx4Zm5wIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjkyODQ3OTQsImV4cCI6MjA4NDg2MDc5NH0.WgTj-6ADFEMrCgPNxeQZvknBBJI1c9uDY9_8Qlkqu4w";
const sb = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

/* anon_id stable per device */
function getAnonId(){
  const key = "mood_anon_id";
  let v = localStorage.getItem(key);
  if(!v){
    v = (crypto.randomUUID ? crypto.randomUUID() : String(Date.now()) + "-" + Math.random());
    localStorage.setItem(key, v);
  }
  return v;
}

/* =============================================================================
   6) Save flow
   ============================================================================= */
btnSave.onclick = async () => {
  setMsg("Locating‚Ä¶");
  btnSave.disabled = true;

  if (!navigator.geolocation) {
    setMsg("Geolocation is not supported on this device.");
    btnSave.disabled = false;
    return;
  }

  navigator.geolocation.getCurrentPosition(async (pos) => {
    const coords = { lat: pos.coords.latitude, lon: pos.coords.longitude };
    const mood = parseInt(slider.value, 10);
    const anonId = getAnonId();

    setMsg("Saving your mood‚Ä¶");

    // IMPORTANT: no "location" field (avoids geography issues)
    const row = { anon_id: anonId, mood, lon: coords.lon, lat: coords.lat };

    const { error } = await sb
      .from("mood_entries")
      .upsert(row, { onConflict: "anon_id" });

    if (error) {
      // friendly message + show real error in console
      setMsg("Save failed: " + (error.message || "Unknown error"));
      console.warn("SAVE error:", error);
      btnSave.disabled = false;
      return;
    }

    revealedThisSession = true;

    setMsg("Thank you! Loading the world‚Äôs mood‚Ä¶");
    map.easeTo({ center: [coords.lon, coords.lat], zoom: Math.max(map.getZoom(), 8) });

    setTimeout(async () => {
      await refreshPoints(sb);
      setMsg("‚úÖ Saved! The world‚Äôs mood is now visible.");
      btnSave.disabled = false;
    }, 800);

  }, (err) => {
    setMsg("Geolocation error: " + err.message);
    btnSave.disabled = false;
  }, { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 });
};

/* =============================================================================
   7) Init
   ============================================================================= */
map.on("load", async () => {
  ensureMoodImages();
  initPointsSourceAndLayers();

  // always hidden at first load
  revealedThisSession = false;
  clearMarkers();
  setMsg("");
});
</script>
</body>
</html>
