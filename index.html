<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Mood Map</title>

<link rel="stylesheet" href="./maplibre-gl.css">

<style>
  html, body { margin:0; height:100%; font:16px system-ui; }
  #map { position:fixed; inset:0; }

  #panel{
    position: fixed;
    z-index: 10;
    background: rgba(255,255,255,0.96);
    border-radius: 16px;
    box-shadow: 0 14px 36px rgba(0,0,0,.25);
    padding: 16px;
    transition: all .35s ease;
  }

  .panel-welcome{
    left:50%; top:50%;
    transform:translate(-50%,-50%);
    width: min(440px, calc(100vw - 24px));
  }

  .panel-app{
    left:12px; top:12px;
    transform:none;
    width: 320px;
  }

  /* Ultra compact after first successful save (mobile-friendly) */
  .panel-compact{
    left:12px; top:12px;
    transform:none;
    width: auto;
    padding: 10px 12px;
    border-radius: 14px;
  }

  h3 { margin:0 0 10px; font-size:18px; }
  .row { display:grid; gap:10px; margin:10px 0; }

  input, button{
    font:inherit;
    padding:12px;
    border-radius:12px;
    border:1px solid rgba(0,0,0,.15);
  }
  button{ background:#111; color:#fff; border:0; cursor:pointer; }
  button.secondary{ background:#eee; color:#111; }
  button.link{
    background: transparent;
    color: #111;
    border: 0;
    padding: 0;
    text-align: left;
    text-decoration: underline;
    cursor: pointer;
    font-size: 14px;
    opacity: .85;
  }

  #welcomeBox{
    background: linear-gradient(135deg,#ffecd2,#fcb69f);
    border-radius:14px;
    padding:14px;
  }

  .small{ font-size:13px; opacity:.75; }
  .msg{ white-space:pre-wrap; font-size:13px; }

  #authView,#appView,#compactView{ display:none; }

  /* Mobile tweaks */
  @media (max-width: 520px) {
    .panel-welcome{ width: calc(100vw - 24px); }
    .panel-app{ width: calc(100vw - 24px); left: 12px; right: 12px; }
    button, input { padding: 14px; font-size: 16px; } /* prevents iOS zoom on inputs */
    .panel-compact{ left: 12px; right: 12px; }
  }

  /* iPhone safe areas */
  #panel{
    padding-bottom: calc(16px + env(safe-area-inset-bottom));
    padding-top: calc(16px + env(safe-area-inset-top));
  }

  :root { --vh: 1vh; }
  #map { height: calc(var(--vh) * 100); }
</style>
</head>

<body>
<div id="map"></div>

<div id="panel" class="panel-welcome">
  <h3>Mood Map</h3>

  <!-- WELCOME / AUTH -->
  <div id="authView">
    <div id="welcomeBox">
      <b>Welcome üåç</b><br><br>
      Discover the mood of the world.<br>
      Create an account to share how you feel and explore
      how happy people are across different places.
    </div>

    <div class="row">
      <input id="email" type="email" placeholder="Email" autocomplete="email">
      <input id="password" type="password" placeholder="Password" autocomplete="current-password">
    </div>

    <div class="row" style="grid-template-columns:1fr 1fr">
      <button id="btnLogin">Sign in</button>
      <button id="btnSignup" class="secondary">Create account</button>
    </div>

    <!-- Forgot password -->
    <div class="row">
      <button id="btnForgot" class="link" type="button">Forgot your password?</button>
      <div class="small">We will email you a reset link.</div>
    </div>

    <div id="authMsg" class="msg"></div>
  </div>

  <!-- APP (full panel) -->
  <div id="appView">
    <div class="row">
      <label>Your mood: <b><span id="moodValue">5</span>/10</b></label>
      <input id="slider" type="range" min="0" max="10" value="5">
    </div>

    <div class="row">
      <button id="btnSaveAll">Locate + Save + Refresh</button>
    </div>

    <div class="small">Markers appear after your first save.</div>
    <div id="appMsg" class="msg"></div>

    <div class="row">
      <button id="btnLogout" class="secondary">Sign out</button>
    </div>
  </div>

  <!-- COMPACT panel (after save) -->
  <div id="compactView">
    <div class="small" id="compactMsg">‚úÖ Saved.</div>
    <div class="row" style="margin-top:8px;">
      <button id="btnLogout2" class="secondary">Sign out</button>
    </div>
  </div>
</div>

<script src="./maplibre-gl.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

<script>
// --- Fix mobile viewport height (iOS) ---
function setVh() {
  document.documentElement.style.setProperty('--vh', `${window.innerHeight * 0.01}px`);
}
window.addEventListener('resize', setVh);
setVh();

/* ================= MAP ================= */
const map = new maplibregl.Map({
  container: "map",
  style: {
    version:8,
    sources:{
      osm:{
        type:"raster",
        tiles:[
          "https://a.tile.openstreetmap.org/{z}/{x}/{y}.png",
          "https://b.tile.openstreetmap.org/{z}/{x}/{y}.png",
          "https://c.tile.openstreetmap.org/{z}/{x}/{y}.png"
        ],
        tileSize:256,
        attribution:"¬© OpenStreetMap contributors"
      }
    },
    layers:[{ id:"osm", type:"raster", source:"osm" }]
  },
  center:[0,20],
  zoom:2
});
map.addControl(new maplibregl.NavigationControl(), "top-right");

/* ================= MOOD ICONS ================= */
function lerp(a,b,t){ return a+(b-a)*t; }
function lerpColor(c1,c2,t){
  const r=Math.round(lerp(c1[0],c2[0],t));
  const g=Math.round(lerp(c1[1],c2[1],t));
  const b=Math.round(lerp(c1[2],c2[2],t));
  return `rgb(${r},${g},${b})`;
}
function moodImageData(level,size=96){
  const t=Math.max(0,Math.min(1,level/10));
  const red=[215,25,28], yellow=[255,255,191], green=[26,150,65];
  const fill=(t<0.5)?lerpColor(red,yellow,t/0.5):lerpColor(yellow,green,(t-0.5)/0.5);

  const canvas=document.createElement("canvas");
  canvas.width=size; canvas.height=size;
  const ctx=canvas.getContext("2d");
  const cx=size/2, cy=size/2, r=size*0.42;

  ctx.beginPath(); ctx.arc(cx,cy+3,r,0,Math.PI*2);
  ctx.fillStyle="rgba(0,0,0,0.18)"; ctx.fill();

  ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2);
  ctx.fillStyle=fill; ctx.fill();
  ctx.lineWidth=Math.max(3,size*0.04);
  ctx.strokeStyle="rgba(0,0,0,0.25)"; ctx.stroke();

  const eyeY=cy-size*0.10, eyeDX=size*0.14, eyeR=size*0.04;
  ctx.beginPath();
  ctx.arc(cx-eyeDX,eyeY,eyeR,0,Math.PI*2);
  ctx.arc(cx+eyeDX,eyeY,eyeR,0,Math.PI*2);
  ctx.fillStyle="rgba(0,0,0,0.75)"; ctx.fill();

  const browY=eyeY-size*0.08;
  const browTilt=lerp(0.20,-0.20,t);
  ctx.lineWidth=Math.max(3,size*0.035);
  ctx.strokeStyle="rgba(0,0,0,0.55)";
  ctx.lineCap="round";

  ctx.beginPath();
  ctx.moveTo(cx-eyeDX-size*0.06, browY + browTilt*size*0.08);
  ctx.lineTo(cx-eyeDX+size*0.06, browY - browTilt*size*0.08);
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(cx+eyeDX-size*0.06, browY - browTilt*size*0.08);
  ctx.lineTo(cx+eyeDX+size*0.06, browY + browTilt*size*0.08);
  ctx.stroke();

  const mouthY=cy+size*0.12, mouthW=size*0.26;
  const curvature=lerp(-1,1,t);
  ctx.beginPath();
  ctx.moveTo(cx-mouthW,mouthY);
  ctx.quadraticCurveTo(cx, mouthY + curvature*size*0.12, cx+mouthW, mouthY);
  ctx.strokeStyle="rgba(0,0,0,0.70)";
  ctx.lineWidth=Math.max(4,size*0.05);
  ctx.lineCap="round";
  ctx.stroke();

  const img=ctx.getImageData(0,0,size,size);
  return { width: img.width, height: img.height, data: img.data };
}
function ensureMoodImages(){
  for(let lvl=0; lvl<=10; lvl++){
    const name=`mood-${lvl}`;
    if(!map.hasImage(name)) map.addImage(name, moodImageData(lvl,96));
  }
}

/* ================= POINTS SOURCE + LAYERS ================= */
let pointsEnabled = false;

function initPointsSourceAndLayers(){
  if(map.getSource("points")) return;

  map.addSource("points", {
    type: "geojson",
    data: { type:"FeatureCollection", features: [] },
    cluster: true,
    clusterRadius: 60,
    clusterMaxZoom: 14,
    clusterProperties: {
      sum: ["+", ["get", "value"]],
      count: ["+", 1]
    }
  });

  const avgRoundedClamped = [
    "case",
    ["<", ["round", ["/", ["get","sum"], ["get","count"]]], 0], 0,
    [">", ["round", ["/", ["get","sum"], ["get","count"]]], 10], 10,
    ["round", ["/", ["get","sum"], ["get","count"]]]
  ];

  map.addLayer({
    id: "clusters-mood",
    type: "symbol",
    source: "points",
    filter: ["has", "point_count"],
    layout: {
      "icon-image": ["concat","mood-", ["to-string", avgRoundedClamped]],
      "icon-size": ["step", ["get","point_count"], 0.65, 10, 0.75, 50, 0.9, 200, 1.05, 1000, 1.2],
      "icon-allow-overlap": true,
      "text-field": ["to-string", ["get","point_count"]],
      "text-size": 12,
      "text-offset": [0, 1.55],
      "text-allow-overlap": true,
      "text-anchor": "top"
    },
    paint: {
      "text-color": "rgba(0,0,0,0.75)",
      "text-halo-color": "rgba(255,255,255,0.9)",
      "text-halo-width": 1
    }
  });

  map.addLayer({
    id: "points-mood",
    type: "symbol",
    source: "points",
    filter: ["!", ["has", "point_count"]],
    layout: {
      "icon-image": [
        "concat","mood-",
        ["to-string",
          ["case",
            ["<", ["round", ["get","value"]], 0], 0,
            [">", ["round", ["get","value"]], 10], 10,
            ["round", ["get","value"]]
          ]
        ]
      ],
      "icon-size": 0.55,
      "icon-allow-overlap": true
    }
  });

  map.on("click", "clusters-mood", (e) => {
    const f = e.features[0];
    map.getSource("points").getClusterExpansionZoom(
      f.properties.cluster_id,
      (err, zoom) => {
        if (err) return;
        map.easeTo({ center: f.geometry.coordinates, zoom });
      }
    );
  });

  map.on("mouseenter", "clusters-mood", () => map.getCanvas().style.cursor = "pointer");
  map.on("mouseleave", "clusters-mood", () => map.getCanvas().style.cursor = "");
}

async function refreshPoints(){
  const source = map.getSource("points");
  if(!source) return;
  if(!pointsEnabled) return; // show nothing until first save (ever)

  const { data, error } = await sb
    .from("mood_entries")
    .select("mood, lon, lat")
    .order("created_at", { ascending:false })
    .limit(20000);

  if(error){
    setAppMessage("Load error:\n" + error.message);
    return;
  }

  const features = (data || [])
    .filter(r => typeof r.lon==="number" && typeof r.lat==="number")
    .map(r => ({
      type: "Feature",
      properties: { value: r.mood },
      geometry: { type:"Point", coordinates:[r.lon, r.lat] }
    }));

  source.setData({ type:"FeatureCollection", features });
  setAppMessage(`Loaded markers: ${features.length}`);
}

/* ================= UI HELPERS ================= */
const el = id => document.getElementById(id);
const panel = el("panel");
function setAuthMessage(msg){ el("authMsg").textContent = msg || ""; }
function setAppMessage(msg){ el("appMsg").textContent = msg || ""; }

const slider = el("slider");
slider.oninput = ()=>el("moodValue").textContent = slider.value;

/* ================= MUSIC (fade out on login) ================= */
let audioCtx, masterGain, musicStarted = false;
let musicNodes = [];
let chordTimer = null;

function stopLoopTimers() {
  if (chordTimer) { clearTimeout(chordTimer); chordTimer = null; }
}

function fadeOutMusic(seconds = 2.5) {
  if (!audioCtx || !masterGain) return;

  const now = audioCtx.currentTime;
  masterGain.gain.cancelScheduledValues(now);
  masterGain.gain.setValueAtTime(masterGain.gain.value, now);
  masterGain.gain.linearRampToValueAtTime(0.0001, now + seconds);

  setTimeout(() => {
    try { stopLoopTimers(); } catch {}
    for (const n of musicNodes) {
      try { n.stop && n.stop(); } catch {}
      try { n.disconnect && n.disconnect(); } catch {}
    }
    musicNodes = [];
    // keep musicStarted=true so it won't restart again
  }, (seconds + 0.3) * 1000);
}

function playAmbientMusic() {
  if (musicStarted) return;
  musicStarted = true;

  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  masterGain = audioCtx.createGain();
  masterGain.gain.value = 0.22;
  masterGain.connect(audioCtx.destination);

  const lp = audioCtx.createBiquadFilter();
  lp.type = "lowpass";
  lp.frequency.value = 1200;
  lp.connect(masterGain);

  const chords = [
    [261.63, 329.63, 392.00],
    [220.00, 261.63, 329.63],
    [174.61, 220.00, 261.63],
    [196.00, 293.66, 392.00]
  ];

  function padChord(freqs, start, dur) {
    for (const f of freqs) {
      const o = audioCtx.createOscillator();
      o.type = "sine";
      o.frequency.value = f;

      const g = audioCtx.createGain();
      g.gain.setValueAtTime(0, start);
      g.gain.linearRampToValueAtTime(0.12, start + 1.2);
      g.gain.linearRampToValueAtTime(0.0, start + dur);

      o.connect(g).connect(lp);
      o.start(start);
      o.stop(start + dur + 0.05);

      musicNodes.push(o, g);
    }
  }

  function arpeggio(freqs, start) {
    const pattern = [0, 1, 2, 1];
    for (let i = 0; i < 8; i++) {
      const f = freqs[pattern[i % pattern.length]] * (i % 2 === 0 ? 2 : 1);
      const o = audioCtx.createOscillator();
      o.type = "triangle";
      o.frequency.value = f;

      const g = audioCtx.createGain();
      const t = start + i * 0.5;
      g.gain.setValueAtTime(0, t);
      g.gain.linearRampToValueAtTime(0.05, t + 0.03);
      g.gain.linearRampToValueAtTime(0, t + 0.45);

      o.connect(g).connect(lp);
      o.start(t);
      o.stop(t + 0.5);

      musicNodes.push(o, g);
    }
  }

  let idx = 0;
  function schedule() {
    const now = audioCtx.currentTime;
    const start = now + 0.02;

    const dur = 7.5;
    const freqs = chords[idx % chords.length];
    padChord(freqs, start, dur);
    arpeggio(freqs, start);

    idx++;
    chordTimer = setTimeout(schedule, dur * 1000);
  }
  schedule();
}

// --- Auto-start music on first user interaction (no button) ---
function autoStartMusicOnce() {
  playAmbientMusic();
  document.removeEventListener("pointerdown", autoStartMusicOnce);
  document.removeEventListener("keydown", autoStartMusicOnce);
}
document.addEventListener("pointerdown", autoStartMusicOnce, { once: true });
document.addEventListener("keydown", autoStartMusicOnce, { once: true });

/* =======================
   SUPABASE
======================= */
const SUPABASE_URL = "https://ugrmxzdhevqrgftlxfnp.supabase.co";
const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVncm14emRoZXZxcmdmdGx4Zm5wIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjkyODQ3OTQsImV4cCI6MjA4NDg2MDc5NH0.WgTj-6ADFEMrCgPNxeQZvknBBJI1c9uDY9_8Qlkqu4w"; // <-- remplace
const sb = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

/* ========= Views / modes ========= */
function showAuth(){
  panel.className = "panel-welcome";
  el("authView").style.display="block";
  el("appView").style.display="none";
  el("compactView").style.display="none";
}
function showApp(){
  panel.className = "panel-app";
  el("authView").style.display="none";
  el("appView").style.display="block";
  el("compactView").style.display="none";
}
function showCompact(msg="‚úÖ Saved."){
  panel.className = "panel-compact";
  el("compactMsg").textContent = msg;
  el("authView").style.display="none";
  el("appView").style.display="none";
  el("compactView").style.display="block";
}

async function checkIfUserHasMoodEntry(userId){
  const { data, error } = await sb
    .from("mood_entries")
    .select("user_id")
    .eq("user_id", userId)
    .limit(1);

  if (error) return false;
  return (data && data.length > 0);
}

async function setConnected(user){
  if(user){
    showApp();
    // Fade music out on login
    fadeOutMusic(2.8);

    // If the user already saved once in the past, enable markers immediately.
    const hasEntry = await checkIfUserHasMoodEntry(user.id);
    if (hasEntry){
      pointsEnabled = true;
      await refreshPoints();
    }
  }else{
    pointsEnabled = false;
    showAuth();
  }
}

sb.auth.getSession().then(r=>setConnected(r.data.session?.user || null));
sb.auth.onAuthStateChange((_e,s)=>setConnected(s?.user || null));

/* ========= Auth buttons ========= */
el("btnSignup").onclick=async()=>{
  const email=el("email").value.trim();
  const password=el("password").value;
  if(!email) return setAuthMessage("Error: empty email");
  if(!password || password.length<6) return setAuthMessage("Error: password must be at least 6 chars");

  setAuthMessage("Creating account‚Ä¶");
  const {error}=await sb.auth.signUp({ email, password });
  setAuthMessage(error ? ("Error:\n"+error.message) : "Account created. You can sign in.");
};

el("btnLogin").onclick=async()=>{
  const email=el("email").value.trim();
  const password=el("password").value;
  setAuthMessage("Signing in‚Ä¶");
  const {error}=await sb.auth.signInWithPassword({ email, password });
  setAuthMessage(error ? ("Error:\n"+error.message) : "");
};

async function doLogout(){
  await sb.auth.signOut();
  setAppMessage("");
  showAuth();
}
el("btnLogout").onclick = doLogout;
el("btnLogout2").onclick = doLogout;

/* ========= Forgot password ========= */
el("btnForgot").onclick = async () => {
  const email = el("email").value.trim();
  if (!email) { setAuthMessage("Please enter your email first."); return; }

  setAuthMessage("Sending reset email‚Ä¶");
  const { error } = await sb.auth.resetPasswordForEmail(email, {
    redirectTo: "https://www.mood2know.com"
  });

  if (error) {
    setAuthMessage("Error:\n" + error.message);
  } else {
    setAuthMessage("‚úÖ Reset email sent. Check your inbox (and spam).");
  }
};

/* ================= ONE BUTTON: Locate + Save + Refresh ================= */
el("btnSaveAll").onclick = async () => {
  setAppMessage("Locating‚Ä¶");

  const { data: { user } } = await sb.auth.getUser();
  if (!user) { setAppMessage("You must be signed in."); return; }

  if (!navigator.geolocation) {
    setAppMessage("Geolocation not supported.");
    return;
  }

  navigator.geolocation.getCurrentPosition(async (pos) => {
    const coords = { lat: pos.coords.latitude, lon: pos.coords.longitude };
    const mood = parseInt(slider.value, 10);

    setAppMessage("Saving‚Ä¶");

    const row = {
      user_id: user.id,
      mood,
      lon: coords.lon,
      lat: coords.lat,
      location: `POINT(${coords.lon} ${coords.lat})`
    };

    const { error } = await sb
      .from("mood_entries")
      .upsert(row, { onConflict: "user_id" });

    if (error) { setAppMessage("Save error:\n" + error.message); return; }

    map.easeTo({ center: [coords.lon, coords.lat], zoom: Math.max(map.getZoom(), 8) });

    pointsEnabled = true;
    setAppMessage("‚úÖ Saved. Loading markers‚Ä¶");
    await refreshPoints();

    // After a successful save, switch to ultra-compact panel (better on iPhone)
    showCompact("‚úÖ Saved. Thank you!");

  }, (err) => {
    setAppMessage("Geolocation error: " + err.message);
  }, { enableHighAccuracy: true, timeout: 10000 });
};

/* ================= MAP init ================= */
map.on("load", async () => {
  ensureMoodImages();
  initPointsSourceAndLayers();
  // Markers appear after first save (or if user already has an entry).
});
</script>
</body>
</html>
